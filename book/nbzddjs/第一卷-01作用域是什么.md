### 一、编译原理

##### `1、传统编译语言的流程`
    1、分词/词法分析
    2、解析/语法分析
    3、代码生成

##### `2、javascript的编译`
     javascript在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化,包括对冗余元素进行优化,对于 JavaScript来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短)的时间内.

### 二、理解作用域

##### `1、引擎` 
    从头到尾负责整个JavaScript 程序的编译及执行过程。

##### `2、编译器` 
    负责语法分析及代码生成脏活累活。

##### `3、作用域` 
    负责收集并维护由所有声明的标识符（变量）组成的一系列查询,并实施一套非常严格的规则,确定当前执行的代码对这些标识符的访问权限。

##### `4、解析变量赋值`
    var a =2;

    1、遇到var a 编译器在执行时首先会检查a变量是否存在同一个作用域集合中,如果在就忽略继续进行编译,如果不在就会在当前作用域中声明一个新的变量a.

    2、编译器会为引擎生成运行时所需的代码，这些代码用于处理a=2的赋值操作,同样引擎在执行过程中会去当前作用于集合中查找a变量,如果存在就会使用这个变量,如果不在引擎会继续在向上的作用域中查找.

* `总结：`

    变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

##### `5、作用域中的LHS和RHS`
    1、赋值操作的目标是谁（LHS）
    2、谁是赋值操作的源头（RHS）

``` .js
function foo(a) { 
  console.log( a ); // 2
} 
foo( 2 );
```
 * `小栗子解析：`

    1、当foo(2)函数在全局作用域执行时需要对foo进行RHS引用<取值操作>

    2、运行到foo函数中有一个隐式赋值将实参2赋值给形参a,那么此时就是对a的LHS引用<赋值操作>

    3、在foo函数作用域内会打印a，此时是取到a的值使用,那么就是对a的RHS引用

* `总结：`
    
    1、当引擎运行对一个不在作用域中的变量进行RHS引用那么就会抛出引用异常。

    2、当引擎运行如果对一个不在所有作用域的变量进行LHS引用,那么会默认在全局作用域中创建这个变量，并返回,前提是非严格模式.


### 三、作用域嵌套

    当一个块或函数嵌套在另一个块或函数中时,就发生了作用域的嵌套。因此,在当前作用 域中无法找到某个变量时,引擎就会在外层嵌套的作用域中继续查找,直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

